# Stealth out
## Caution
This is a useless implementation of an idea I had a while ago. This is just for fun, and SHOULD
NOT be used with real money. Keep in mind that this software is NOT secure, and may leak sensitive information. After that disclaimer, let's see how it works.

## Theory
### Background
Stealth address is a cool idea that arrived in the 2014 if I mind it correctly (I just don't remember who created), it solves the problem of address reuse in case of no interactive setups.  
Let's say Bob is a content creator, and have YouTube channel. Alice is a Bob follower, and want to send some coins to Bob for his great job. If Bob have knowledge/ways to implement a donation site using, say BTCPay, his wallet can create a fresh new address when Alice request, using any BIP32-like method. However, there are situations where this is not possible, and Bob only leave a fixed donation address in his videos. This is bad, this forces Bob to reuse addresses, and creates a link Between Alice's UTXO(s) and Bob.  
With stealth addresses, Bob does leave a fixed address, but this address isn't the one Alice will pay to, this is a "template" for creating a brand-new address that only Alice and Bob knows where it came from.  
The address, it's two Elliptic Curve public keys, `A` and `B`. Alice, with the knowledge of this key, MUST generate a one-time secret `r`, and use `r` for ECDH with `A`. The resulting point is hashed, and we take `P = H(rA)G + B`. `P` is the one-time key Alice will pay for, and Alice MUST publish `rG`, but MUST NOT reveal `r` to anyone else.  
Later on, Bob will scan the blockchain trying to find any payment to him. He parses each transaction, with the knowledge of `a` (the private part) and `B` (yet the public one). For each output, parse `R` and take `P' = H(aR) + B`. If `P' == P`, where `P` is the receiver of a given UTXO, then it's for him. The private key for `P` is `H(aR) + b`, because only Bob knows `b`, only he can reconstruct this private key.  
Very simple, BUT (there is always a “but”), Alice MUST publish `R`, with is a 33-byte x-only EC point. The way it was meant is that Alice would OP-return `R` along with the transaction, but it would impose a big overhead on the blockchain, and decreases Bob's anonymity set, because the OP_RETURN flags the tx as being a pay-to-a-stealth-address one. Another problem is that Bob needs to parse every block and every tx to find his transactions, computing the expensive ECDH and the EC group addition. This repository has my solution to the first problem, the second isn't that difficult to solve, a good backup strategy, would work (it does work in some altcoins like monero).  

### The idea
As I mentioned before, one problem is the `R` value that should be committed somewhere, like OP-returning it, with reduce the privacy gains and create extra data usage (more fees and more precious blockchain space). But thinking about `R`, it's the public part of `r`, with is a secret generated by Alice, and she MUST NOT share it, and even though Bob know about the transaction destination (he itself), he can't guess `r`, and he doesn't need it! Every single transaction contains inputs and outputs, the inputs are outputs from previous transactions. These outputs have a locking script that must be fulfilled in order to unlock and spend those coins. The input links to previous output and contains the data need for unlocking it. The most common type of spend condition is requiring a signature to some given public key. The public key have it's corresponding private key, and it's assumed that even AFTER the output being spent, the private key is kept in secret, especially if the wallet is HD, because a private key and a xpub give access to all UTXOs using a "child" private key. If the private key is secret, and we DO HAVE the public part within the blockchain. Why don't we use this private key for ECDH, since it DOES NOT expose the private key (because… math)? That's the idea!
## The software
### Compiling
Install the dependencies
```
$ sudo apt-get install libsecp256k1 lssl libcurl libjson-c
```
And compile
```
$ make
```

### Using
Create a new wallet with. Note that the seed isn't a BIP39 seed, more like a brain wallet.
```
$ ./main create-wallet -s <seed>
```
Get our stealth address
```
$ ./main show-address
```
Generate the address to send the coins
```
$ ./main invoice -a <stealth_address> -p <sender Private Key>
```
After the payment have been made, you can scan the blockchain trying find the tx
```
$ ./main rescan -c <rpc_connection>
```
Now you can get the private key for spending. You can use it with `importdescriptor` in Bitcoin Core
```
$ ./main spend -t <transaction_id>
```